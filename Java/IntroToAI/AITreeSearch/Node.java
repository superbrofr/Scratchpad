/**
* A node in the search tree. Stores its parent, a puzzle grid state, and all costs associated
* with the node (cost given the heuristic, path cost and the total value of the evaluation function).
* Also stores the action made by the nodes parent to get to that node.
* @author Charlotte and Div
*/
public class Node implements Comparable<Node>
{
  private Node parent;
  private int totalCost; //f(n)
  private int pathCost; //g(n)
  private int heuristicCost; //h(n)
  private int[][] state;
  private Action action; //action made by parent to get to this node
  
  /**
  * Creates a new node with the specified parent.
  * Uses the state and the action performed to create the state of the node.
  * @param aParent The node's parent node.
  * @param aState The parent node's state.
  * @param anAction The action performed by the parent node to generate this node.
  */
  public Node(Node aParent, int[][] aState, Action anAction)
  {
    //Initialise costs to 0
    totalCost = 0;
    pathCost = 0;
    heuristicCost = 0;
    parent = aParent;
    action = anAction;
    state = new int[aState.length][aState[0].length];
    copyState(state, aState);//copy state over to avoid referencing issues
    if(action != null){
      state = getNewState(state, action);
    }
    else{
      state = aState;
    }
  }
  
  /**
  * Copies the structure of one state into another.
  * Needs to be used when creating a new node to avoid referencing issues.
  * @param copyTo The puzzle grid to copy the state to.
  * @param copyFrom The puzzle grid to copy from.
  */
  private void copyState(int[][] copyTo, int[][] copyFrom)
  {
    for(int i = 0; i < copyFrom.length; i++){
      for(int j = 0; j < copyFrom[0].length; j++){
        copyTo[i][j] = copyFrom[i][j];
      }
    }
  }
  
  /**
  * Performs the action made by the parent node on the parent's puzzle state, and returns the new state.
  * @param aState The parent's state.
  * @param anAction The parent's action.
  * @return The new state generated by 'aState' and 'anAction'
  */
  private int[][] getNewState(int[][] aState, Action anAction)
  {
    //get current 'old' state of blank in index for (minus 1)
    int x = (anAction.getX() - 1);
    int y = (anAction.getY() - 1);
    int temp; //the number that is being swapped with blank - will be assigned blank's old position
    
    if(anAction.getDirection() == Direction.UP){
      temp = aState[x][(y - 1)];
      aState[x][(y - 1)] = 0;
      aState[x][y] = temp;
    }
    else if(anAction.getDirection() == Direction.DOWN){
      temp = aState[x][(y + 1)];
      aState[x][(y + 1)] = 0;
      aState[x][y] = temp;
    }
    else if(anAction.getDirection() == Direction.LEFT){
      temp = aState[(x - 1)][y];
      aState[(x - 1)][y] = 0;
      aState[x][y] = temp;
    }
    else if(anAction.getDirection() == Direction.RIGHT){
      temp = aState[(x + 1)][y];
      aState[(x + 1)][y] = 0;
      aState[x][y] = temp;
    }
    return aState;
  }
  
  /**
  * Prints out the state of the node.
  */
  public void printState()
  {
    for(int i = 0; i < state[0].length; i++){
      for(int j = 0; j < state.length; j++){
        if(state[j][i] >= 10){
          System.out.print("[" + state[j][i] + "]");
        }
        else if(state[j][i] == 0){
          System.out.print("[  ]");
        }
        else{
          System.out.print("[" + state[j][i] + " ]");
        }
      }
      System.out.println();
    }
  }
  
  /**
  * Returns the state of the node.
  * @return The state of the node.
  */
  public int[][] getState()
  {
    return state;
  }
  
  /**
  * Returns the parent of the node.
  * @return The parent of the node.
  */
  public Node getParent()
  {
    return parent;
  }
  
  /**
  * Returns the action performed to get this node.
  * @return The action performed to get this node.
  */
  public Action getAction()
  {
    return action;
  }
  
  /**
  * Returns the total cost (i.e. f(n) - the evaluation function) of the node.
  * @return The total cost of this node.
  */
  public int getTotalCost()
  {
    return totalCost;
  }
  
  /**
  * Returns the heuristic value (i.e. h(n)) of the node.
  * @return The heuristic value of the node.
  */
  public int getHeuristicCost()
  {
    return heuristicCost;
  }
  
  /**
  * Returns the path cost (i.e. g(n)) to get to the node.
  * @return The path cost of the node.
  */
  public int getPathCost()
  {
    return pathCost;
  }
  
  /**
  * Set the path cost of the node and update the total cost.
  * @param aCost The new path cost.
  */
  public void setPathCost(int aCost)
  {
    pathCost = aCost;
    totalCost = pathCost + heuristicCost;
  }
  
  /**
  * Set the heuristic cost of the node and update the total cost.
  * @param aCost The new heuristic cost.
  */
  public void setHeuristicCost(int aCost)
  {
    heuristicCost = aCost;
    totalCost = pathCost + heuristicCost;
  }
  
  /**
  * Sets the precedent for comparing nodes in a list.
  * Comparing is based on the total cost of a node, so that sorting places
  * the node with the lowest total cost at the start of the fringe.
  * @param otherNode The node to compare to this.
  * @return Returns 1 if this node has a greater cost than other node, a -1 if this node has a lower cost, and 0 if they are equal.
  */
  public int compareTo(Node otherNode)
  {	
    if(this.getTotalCost() > otherNode.getTotalCost()){
      return 1;
    }
    else if(this.getTotalCost() < otherNode.getTotalCost()){
      return -1;
    }
    else{
      return 0;
    }
  }
}